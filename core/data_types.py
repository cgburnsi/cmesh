''' core/data_types.py 
    ------------------
    Data Structures (Storage Arrays) Definitions Used by SnapMesh
    
    This module defines the structured NumPy arrays data types used to store:
        
    - Mesh Generation Data
        1 - TOPOLOGY DATA (Nodes, Faces, and Cells)
        2 - CONSTRAINTS (Geometry)
        3 - MANIPULATION (Field Density Changes)
        
    These structures are used across throughout the SnapMesh code.
    
    Key Concepts:
    - IDs are typically 1-based (matching the input file).
    - Indices (if derived) are 0-based.
    - 'segments' in FACE_DTYPE controls the Locked Boundary logic.
    - 'sources' drive the Sizing Field gradient.
'''
import numpy as np

# -----------------------------------------------------------------------------
# 1. Topology Elements (Nodes, Faces, Cells)
# -----------------------------------------------------------------------------

# NODES: The fundamental vertices of the mesh.
NODE_DTYPE = np.dtype([
    ('id', 'i4'),       # Unique Node Identifier (Input File ID)
    ('x',  'f8'),       # X-Coordinate (float64)
    ('y',  'f8')        # Y-Coordinate (float64)
])

# FACES: The boundary edges connecting two nodes.
FACE_DTYPE = np.dtype([
    ('id',  'i4'),      # Unique Face Identifier
    ('n1',  'i4'),      # Start Node ID
    ('n2',  'i4'),      # End Node ID
    ('tag', 'i4'),      # Boundary Condition Tag (e.g., 1=Wall, 2=Inlet)
    ('segments', 'i4')  # LOCKED COUNT: The exact number of edges to generate 
                        # on this face. If > 0, the boundary is "locked".
])

# CELLS: The triangular elements generated by the solver.
CELL_DTYPE = np.dtype([
    ('id', 'i4'),       # Unique Cell Identifier
    ('f1', 'i4'),       # Neighbor/Face 1
    ('f2', 'i4'),       # Neighbor/Face 2
    ('f3',  'i4')       # Neighbor/Face 3
])

# -----------------------------------------------------------------------------
# 2. Constraints (Geometric and Boundaries)
# -----------------------------------------------------------------------------

# CONSTRAINTS: Geometric shapes that faces project onto.
CONSTRAINT_DTYPE = np.dtype([
    ('id', 'i4'),       # Constraint ID
    ('type', 'i4'),     # Type Marker: 1=Line, 2=Circle/Arc
    ('target', 'i4'),   # The Face ID this constraint applies to (0 = Global)
    ('p1', 'f8'),       # Parameter 1 (e.g., Center X or Line Start)
    ('p2', 'f8'),       # Parameter 2 (e.g., Center Y or Line End)
    ('p3', 'f8')        # Parameter 3 (e.g., Radius or ignored)
])


BC_DTYPE = np.dtype([
    ('id', 'i4'),       # Boundary Constraint ID
    ('type', 'i4'),     # Type Marker:  1=Dirichlet, 2=Neumann
    ('v', 'f8')         # Boundary value
])


# -----------------------------------------------------------------------------
# 3. Sizing Field Sources
# -----------------------------------------------------------------------------

# SOURCES: Regions of influence for mesh refinement.
FIELD_DTYPE = np.dtype([
    ('id', 'i4'),       # Source ID
    ('type', 'i4'),     # Source Type:
                        #   0 = Global Background Size
                        #   1 = Box Region (Requires x1, y1, x2, y2)
                        
    ('x1', 'f8'),       # Bounding Box Min X
    ('y1', 'f8'),       # Bounding Box Min Y
    ('x2', 'f8'),       # Bounding Box Max X
    ('y2', 'f8'),       # Bounding Box Max Y
    
    ('v', 'f8')         # Target Element Size (h) inside this region.
                        # The sizing field will create a gradient from this 
                        # value back to the background size.
])
    
    